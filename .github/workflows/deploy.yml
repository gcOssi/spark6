name: Provision & Deploy (staging)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-staging
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: staging-dashboard
  IMAGE_TAG: ${{ github.sha }}

jobs:
  provision-infra:
    runs-on: ubuntu-latest
    outputs:
      ECS_CLUSTER: ${{ steps.capture.outputs.ECS_CLUSTER }}
      ECS_SERVICE: ${{ steps.capture.outputs.ECS_SERVICE }}
      ECR_FRONTEND: ${{ steps.capture.outputs.ECR_FRONTEND }}
      ECR_BACKEND:  ${{ steps.capture.outputs.ECR_BACKEND }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Terraform Init
        working-directory: infrastructure
        run: terraform init -input=false

      # Ajusta estas -var con tus valores por defecto o usa repo variables si prefieres
      - name: Terraform Apply
        working-directory: infrastructure
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          terraform apply -auto-approve \
            -var="github_owner=${{ vars.GITHUB_OWNER || 'gcOssi' }}" \
            -var="github_repo=${{ vars.GITHUB_REPO || 'spark6' }}" \
            -var="alert_email=${{ vars.ALERT_EMAIL || 'gcadddbrera@ddd.cl' }}" \
            -var="image_tag=latest" \
            -var="build_platform=linux/amd64" \
            -var="react_app_api_url=${{ vars.REACT_APP_API_URL || '/api' }}"

      - name: Capture Terraform outputs
        id: capture
        working-directory: infrastructure
        run: |
          echo "ECS_CLUSTER=$(terraform output -raw ecs_cluster)" >> $GITHUB_OUTPUT
          echo "ECS_SERVICE=$(terraform output -raw ecs_service)" >> $GITHUB_OUTPUT
          echo "ECR_FRONTEND=$(terraform output -raw ecr_frontend)" >> $GITHUB_OUTPUT
          echo "ECR_BACKEND=$(terraform output -raw ecr_backend)" >> $GITHUB_OUTPUT

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: provision-infra
    env:
      CLUSTER_NAME: ${{ needs.provision-infra.outputs.ECS_CLUSTER }}
      SERVICE_NAME: ${{ needs.provision-infra.outputs.ECS_SERVICE }}
      ECR_FRONTEND: ${{ needs.provision-infra.outputs.ECR_FRONTEND }}
      ECR_BACKEND:  ${{ needs.provision-infra.outputs.ECR_BACKEND }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive   # por si aún tienes submódulos

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Crea repos si faltan (usa AES256 por defecto; evita errores KMS)
      - name: Ensure ECR repositories exist
        shell: bash
        run: |
          set -euo pipefail
          for R in "${ECR_BACKEND}" "${ECR_FRONTEND}"; do
            NAME="${R##*/}"
            if ! aws ecr describe-repositories --repository-names "$NAME" >/dev/null 2>&1; then
              echo "Creating ECR repo: $NAME"
              aws ecr create-repository \
                --repository-name "$NAME" \
                --image-scanning-configuration scanOnPush=true \
                --encryption-configuration encryptionType=AES256 \
                >/dev/null
            else
              echo "ECR repo exists: $NAME"
            fi
          done

      - name: Build & Push BACKEND (linux/amd64)
        run: |
          docker build --platform linux/amd64 \
            -t "$ECR_BACKEND:${IMAGE_TAG}" \
            -t "$ECR_BACKEND:latest" \
            ./backend
          docker push "$ECR_BACKEND:${IMAGE_TAG}"
          docker push "$ECR_BACKEND:latest"

      - name: Build & Push FRONTEND (linux/amd64)
        env:
          REACT_APP_API_URL: ${{ vars.REACT_APP_API_URL || '/api' }}
        run: |
          docker build --platform linux/amd64 \
            --build-arg REACT_APP_API_URL=$REACT_APP_API_URL \
            -t "$ECR_FRONTEND:${IMAGE_TAG}" \
            -t "$ECR_FRONTEND:latest" \
            ./frontend
          docker push "$ECR_FRONTEND:${IMAGE_TAG}"
          docker push "$ECR_FRONTEND:latest"

      # Tomamos una TD base (del service o la última de la familia) y registramos nueva revisión
      - name: Resolve base task definition
        id: base_td
        shell: bash
        run: |
          set -euo pipefail
          FAMILY="${PROJECT_NAME}-task"
          TD_ARN=$(aws ecs describe-services \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --query 'services[0].taskDefinition' \
            --output text 2>/dev/null || true)
          if [[ -z "$TD_ARN" || "$TD_ARN" == "None" ]]; then
            TD_ARN=$(aws ecs list-task-definitions \
              --family-prefix "$FAMILY" \
              --sort DESC --max-items 1 \
              --query 'taskDefinitionArns[0]' \
              --output text 2>/dev/null || true)
          fi
          if [[ -z "$TD_ARN" || "$TD_ARN" == "None" ]]; then
            echo "::error::No Task Definition found for family '$FAMILY'. Run Terraform first."
            exit 1
          fi
          aws ecs describe-task-definition \
            --task-definition "$TD_ARN" \
            --query taskDefinition > td.json

      - name: Prepare new task definition with updated images (sanitize)
        id: taskdef
        shell: bash
        run: |
          set -euo pipefail
          jq \
            --arg fe "$ECR_FRONTEND:${IMAGE_TAG}" \
            --arg be "$ECR_BACKEND:${IMAGE_TAG}" \
            '
            .containerDefinitions |= (map(
              if .name=="frontend" then .image=$fe
              elif .name=="backend" then .image=$be
              else .
              end
            ))
            | {
                family, taskRoleArn, executionRoleArn, networkMode,
                containerDefinitions, volumes, placementConstraints,
                requiresCompatibilities, cpu, memory, tags, pidMode, ipcMode,
                proxyConfiguration, inferenceAccelerators, ephemeralStorage,
                runtimePlatform, enableFaultInjection
              }
            | with_entries(select(.value != null))
            ' td.json > td-new.json

          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td-new.json \
            --query taskDefinition.taskDefinitionArn \
            --output text)

          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_OUTPUT
          echo "Registered: $NEW_TD_ARN"

      - name: Check ECS cluster & service
        shell: bash
        run: |
          set -euo pipefail
          STATUS=$(aws ecs describe-clusters --clusters "$CLUSTER_NAME" --query 'clusters[0].status' --output text || true)
          if [[ -z "$STATUS" || "$STATUS" == "INACTIVE" || "$STATUS" == "None" ]]; then
            echo "::error::ECS cluster '$CLUSTER_NAME' no existe o está INACTIVE."
            exit 1
          fi
          SVC=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" --query 'services[0].status' --output text || true)
          if [[ -z "$SVC" || "$SVC" == "INACTIVE" || "$SVC" == "None" ]]; then
            echo "::error::ECS service '$SERVICE_NAME' no existe. Terraform debe crearlo."
            exit 1
          fi

      - name: Update ECS service to new task definition
        run: |
          aws ecs update-service \
            --cluster "${CLUSTER_NAME}" \
            --service "${SERVICE_NAME}" \
            --task-definition "${{ steps.taskdef.outputs.NEW_TD_ARN }}"

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}"
